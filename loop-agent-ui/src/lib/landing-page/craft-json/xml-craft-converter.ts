/**
 * XML-Craft Converter
 *
 * Provides deterministic two-way conversion between XML-Craft and CraftJSON formats.
 *
 * Key design decisions:
 * - Deterministic ID generation: Same XML always produces identical CraftJSON
 * - Lossless round-trip: XML -> CraftJSON -> XML produces equivalent output
 * - Sensible defaults: Only non-default values are serialized to XML
 * - Validation: Structural and attribute validation during conversion
 */

import type {
  CraftJSON,
  CraftNode,
  PageNode,
  ContainerNode,
  TextNode,
  ButtonNode,
  ImageNode,
  VideoNode,
  CountdownNode,
  FormNode,
  RGBA,
  TextStyleParagraph,
  TextStyleChild,
  VisibilitySettings,
  ClickEvent,
} from "./types";

import {
  ELEMENT_TO_RESOLVED_NAME,
  RESOLVED_NAME_TO_ELEMENT,
  CANVAS_ELEMENTS,
  FORM_FIELD_ELEMENTS,
  SPECIAL_ELEMENTS,
  TRBL_ATTRIBUTES,
  COLOR_ATTRIBUTES,
  BOOLEAN_ATTRIBUTES,
  NUMERIC_ATTRIBUTES,
  COMPONENT_DEFAULTS,
  isRGBAObject,
  isVisibilityObject,
  isGradient,
  isAutoGeneratedId,
  type ConversionContext,
  type ValidationError,
  type TRBL,
  type GradientBackground,
  type ParsedClickEvent,
  type ParsedTextParagraph,
  type ParsedTextSpan,
} from "./xml-craft-types";

// =============================================================================
// DETERMINISTIC ID GENERATION
// =============================================================================

/**
 * Generate a deterministic node ID based on element type, position, and context
 */
function generateDeterministicId(
  elementName: string,
  context: ConversionContext
): string {
  // Get or initialize the counter for this element type
  const key = elementName.toLowerCase();
  const index = context.elementIndices.get(key) ?? 0;
  context.elementIndices.set(key, index + 1);

  // Create deterministic ID: {type}_{timestamp}_{index}
  return `${key}_${context.timestamp}_${index}`;
}

/**
 * Create a new conversion context for deterministic conversion
 */
export function createConversionContext(timestamp?: number): ConversionContext {
  return {
    nodeCounter: 0,
    timestamp: timestamp ?? Date.now(),
    elementIndices: new Map(),
  };
}

// =============================================================================
// XML PARSING UTILITIES
// =============================================================================

/**
 * Parse TRBL (Top, Right, Bottom, Left) value from string
 * Supports: "20" (all), "20,16" (vert/horiz), "20,16,20,16" (t,r,b,l)
 */
function parseTRBL(value: string): TRBL {
  const parts = value.split(",").map((v) => parseFloat(v.trim()));

  if (parts.some(isNaN)) {
    throw new Error(`Invalid TRBL value: ${value}`);
  }

  switch (parts.length) {
    case 1:
      return [parts[0], parts[0], parts[0], parts[0]];
    case 2:
      return [parts[0], parts[1], parts[0], parts[1]];
    case 4:
      return parts as TRBL;
    default:
      throw new Error(`Invalid TRBL format (expected 1, 2, or 4 values): ${value}`);
  }
}

/**
 * Parse RGBA color from string "r,g,b,a" or "r,g,b"
 */
function parseRGBA(value: string): RGBA | null {
  if (!value || value === "" || value === "transparent") {
    return null;
  }

  const parts = value.split(",").map((v) => parseFloat(v.trim()));

  if (parts.length < 3 || parts.length > 4) {
    throw new Error(`Invalid RGBA format: ${value}`);
  }

  if (parts.some(isNaN)) {
    throw new Error(`Invalid RGBA value: ${value}`);
  }

  return {
    r: parts[0],
    g: parts[1],
    b: parts[2],
    a: parts[3] ?? 1,
  };
}

/**
 * Parse visibility string "true,true,false" to object
 */
function parseVisibility(value: string): VisibilitySettings {
  const parts = value.split(",").map((v) => v.trim().toLowerCase() === "true");

  if (parts.length !== 3) {
    throw new Error(`Invalid visibility format (expected 3 booleans): ${value}`);
  }

  return {
    desktop: parts[0],
    tablet: parts[1],
    mobile: parts[2],
  };
}

/**
 * Check if an attribute is boolean for a given component
 */
function isBooleanAttribute(name: string, component: string): boolean {
  if (BOOLEAN_ATTRIBUTES.common?.has(name)) return true;
  if (BOOLEAN_ATTRIBUTES[component]?.has(name)) return true;
  if (component.startsWith("Form") && BOOLEAN_ATTRIBUTES.FormField?.has(name)) return true;
  return false;
}

/**
 * Convert attribute value from string to appropriate type
 */
function convertAttributeValue(
  name: string,
  value: string,
  component: string
): unknown {
  // TRBL attributes
  if (TRBL_ATTRIBUTES.has(name)) {
    return parseTRBL(value);
  }

  // RGBA color attributes
  if (COLOR_ATTRIBUTES.has(name)) {
    return parseRGBA(value);
  }

  // Visibility
  if (name === "visibility") {
    return parseVisibility(value);
  }

  // Boolean
  if (isBooleanAttribute(name, component)) {
    return value.toLowerCase() === "true";
  }

  // Numeric
  if (NUMERIC_ATTRIBUTES.has(name)) {
    const num = parseFloat(value);
    if (isNaN(num)) {
      throw new Error(`Invalid numeric value for ${name}: ${value}`);
    }
    return num;
  }

  // String (default)
  return value;
}

// =============================================================================
// XML TO CRAFTJSON CONVERSION
// =============================================================================

/**
 * Parse a DOM Element and extract its attributes as props
 */
function extractPropsFromElement(
  element: Element,
  resolvedName: string
): Record<string, unknown> {
  const props: Record<string, unknown> = {};
  const defaults = COMPONENT_DEFAULTS[resolvedName] || {};

  // Process each attribute
  for (let i = 0; i < element.attributes.length; i++) {
    const attr = element.attributes[i];
    const { name, value } = attr;

    // Skip special attributes
    if (name === "id" || name === "displayName" || name === "isLocked" || name === "hidden") {
      continue;
    }

    // Skip xmlns attributes
    if (name.startsWith("xmlns")) {
      continue;
    }

    try {
      const convertedValue = convertAttributeValue(name, value, resolvedName);
      if (convertedValue !== undefined) {
        props[name] = convertedValue;
      }
    } catch (e) {
      console.warn(`Failed to convert attribute ${name}="${value}":`, e);
    }
  }

  // Merge with defaults
  return { ...defaults, ...props };
}

/**
 * Parse text paragraph elements (p > span)
 */
function parseTextParagraph(pElement: Element): ParsedTextParagraph {
  const children: ParsedTextSpan[] = [];

  // Process span elements
  const spans = pElement.getElementsByTagName("span");
  for (let i = 0; i < spans.length; i++) {
    const span = spans[i];
    const textSpan: ParsedTextSpan = {
      text: span.textContent || "",
    };

    // Extract span attributes
    if (span.hasAttribute("font")) {
      textSpan.fontFamily = span.getAttribute("font")!;
    }
    if (span.hasAttribute("size")) {
      textSpan.fontSize = span.getAttribute("size")!;
    }
    if (span.hasAttribute("weight")) {
      textSpan.fontWeight = span.getAttribute("weight")!;
    }
    if (span.hasAttribute("style")) {
      textSpan.fontStyle = span.getAttribute("style")!;
    }
    if (span.hasAttribute("transform")) {
      textSpan.textTransform = span.getAttribute("transform")!;
    }
    if (span.hasAttribute("spacing")) {
      textSpan.letterSpacing = parseFloat(span.getAttribute("spacing")!);
    }
    if (span.hasAttribute("color")) {
      textSpan.color = parseRGBA(span.getAttribute("color")!) || undefined;
    }

    children.push(textSpan);
  }

  // Handle direct text content without spans
  if (children.length === 0 && pElement.textContent?.trim()) {
    children.push({
      text: pElement.textContent.trim(),
      fontFamily: "Inter",
      fontSize: "16px",
      fontWeight: "400",
      fontStyle: "normal",
      textTransform: "none",
      letterSpacing: 0,
      color: { r: 0, g: 0, b: 0, a: 1 },
    });
  }

  return { type: "paragraph", children };
}

/**
 * Parse click event element
 */
function parseClickEvent(element: Element): ParsedClickEvent {
  const type = element.getAttribute("type") || "nolink";

  if (type === "nolink") {
    return { eventType: "nolink", eventData: null };
  }

  const eventData: Record<string, unknown> = {};

  if (element.hasAttribute("url")) {
    eventData.url = element.getAttribute("url");
  }
  if (element.hasAttribute("pageId")) {
    eventData.pageId = element.getAttribute("pageId");
  }
  if (element.hasAttribute("elementId")) {
    eventData.optionId = element.getAttribute("elementId");
  }
  if (element.hasAttribute("newTab")) {
    eventData.newTab = element.getAttribute("newTab") === "true";
  }
  if (element.hasAttribute("nofollow")) {
    eventData.useNofollow = element.getAttribute("nofollow") === "true";
  }
  if (element.hasAttribute("fileUrl")) {
    eventData.url = element.getAttribute("fileUrl");
  }

  return { eventType: type, eventData: eventData as ParsedClickEvent["eventData"] };
}

/**
 * Parse gradient element
 */
function parseGradient(element: Element): GradientBackground {
  const type = (element.getAttribute("type") || "Linear") as "Linear" | "Radial";
  const angle = element.hasAttribute("angle")
    ? parseFloat(element.getAttribute("angle")!)
    : undefined;

  const stops: GradientBackground["stops"] = [];
  const stopElements = element.getElementsByTagName("Stop");

  for (let i = 0; i < stopElements.length; i++) {
    const stop = stopElements[i];
    stops.push({
      position: parseFloat(stop.getAttribute("position") || "0"),
      color: stop.getAttribute("color") || "#000000",
    });
  }

  return { type, angle, stops };
}

/**
 * Process breakpoint override elements (Tablet, Mobile)
 */
function processBreakpointOverride(
  element: Element,
  props: Record<string, unknown>,
  component: string
): void {
  const breakpoint = element.tagName.toLowerCase(); // 'tablet' or 'mobile'
  const overrides: Record<string, unknown> = {};

  for (let i = 0; i < element.attributes.length; i++) {
    const attr = element.attributes[i];
    try {
      overrides[attr.name] = convertAttributeValue(attr.name, attr.value, component);
    } catch (e) {
      console.warn(`Failed to convert breakpoint override ${attr.name}:`, e);
    }
  }

  props[breakpoint] = overrides;
}

/**
 * Create a CraftJSON node from an XML element
 */
function createNodeFromElement(
  element: Element,
  parentId: string | null,
  context: ConversionContext
): { id: string; node: CraftNode } {
  const tagName = element.tagName;
  const resolvedName = ELEMENT_TO_RESOLVED_NAME[tagName];

  if (!resolvedName) {
    throw new Error(`Unknown element type: ${tagName}`);
  }

  // Get node ID (explicit or generated)
  const explicitId = element.getAttribute("id");
  const nodeId = explicitId || generateDeterministicId(tagName, context);

  // Determine if canvas element
  const isCanvas = CANVAS_ELEMENTS.has(tagName) || tagName === "Form";

  // Extract props from attributes
  const props = extractPropsFromElement(element, resolvedName);

  // Process special child elements
  const childElements = Array.from(element.children);

  for (const child of childElements) {
    const childTag = child.tagName;

    // Breakpoint overrides
    if (childTag === "Tablet" || childTag === "Mobile") {
      processBreakpointOverride(child, props, resolvedName);
      continue;
    }

    // Click event
    if (childTag === "ClickEvent") {
      const clickEvent = parseClickEvent(child);
      props.clickEvent = clickEvent;
      continue;
    }

    // Expire event (Countdown)
    if (childTag === "ExpireEvent") {
      props.expireEvent = {
        eventType: child.getAttribute("type") || "stay-on-page",
        url: child.getAttribute("url"),
      };
      continue;
    }

    // Followup action (Form)
    if (childTag === "FollowupAction") {
      props.followupAction = {
        type: child.getAttribute("type") || "remain",
        url: child.getAttribute("url"),
        message: child.getAttribute("message"),
      };
      continue;
    }

    // Gradient background
    if (childTag === "Gradient") {
      props.backgroundColor = parseGradient(child);
      continue;
    }

    // Embed code (Video)
    if (childTag === "EmbedCode") {
      props.embedCode = child.textContent;
      continue;
    }

    // Text content (p elements)
    if (childTag === "p" && resolvedName === "Text") {
      if (!props.textStyles) {
        props.textStyles = [];
      }
      (props.textStyles as ParsedTextParagraph[]).push(parseTextParagraph(child));
      continue;
    }

    // Form field options
    if (childTag === "Option") {
      if (!props.options) {
        props.options = [];
      }
      (props.options as Array<{ value: string; label: string }>).push({
        value: child.getAttribute("value") || "",
        label: child.getAttribute("label") || "",
      });
      continue;
    }
  }

  // Handle simple text shorthand (text content directly in Text element)
  if (resolvedName === "Text" && !props.textStyles) {
    // Check for direct text content (not inside <p> tags)
    let directText = "";
    const childNodes = Array.from(element.childNodes);
    for (const childNode of childNodes) {
      if (childNode.nodeType === 3) { // TEXT_NODE
        directText += childNode.textContent || "";
      }
    }
    directText = directText.trim();

    if (directText) {
      const textSpan: TextStyleChild = {
        text: directText,
        fontFamily: (element.getAttribute("font") as string) || "Inter",
        fontSize: (element.getAttribute("size") as string) || "16px",
        fontWeight: (element.getAttribute("weight") as string) || "400",
        fontStyle: (element.getAttribute("style") as string) || "normal",
        textTransform: (element.getAttribute("transform") as string) || "none",
        letterSpacing: element.hasAttribute("spacing")
          ? parseFloat(element.getAttribute("spacing")!)
          : 0,
        color: element.hasAttribute("color")
          ? parseRGBA(element.getAttribute("color")!) || undefined
          : { r: 0, g: 0, b: 0, a: 1 },
      };

      props.textStyles = [{ type: "paragraph", children: [textSpan] }];
    }
  }

  // Create the node
  const node: CraftNode = {
    type: { resolvedName } as CraftNode["type"],
    isCanvas,
    props,
    displayName: resolvedName,
    custom: {
      displayName: element.getAttribute("displayName") || resolvedName,
      isLocked: element.getAttribute("isLocked") === "true",
    },
    hidden: element.getAttribute("hidden") === "true",
    nodes: [],
    linkedNodes: {},
    parent: parentId ?? undefined,
  };

  return { id: nodeId, node };
}

/**
 * Recursively process children of an element
 */
function processChildren(
  element: Element,
  parentId: string,
  craftJson: Record<string, CraftNode | number>,
  context: ConversionContext
): void {
  const parentNode = craftJson[parentId] as CraftNode;
  const childElements = Array.from(element.children);

  for (const child of childElements) {
    const childTag = child.tagName;

    // Skip special elements
    if (SPECIAL_ELEMENTS.has(childTag)) {
      continue;
    }

    // Skip if not a valid component element
    if (!ELEMENT_TO_RESOLVED_NAME[childTag]) {
      console.warn(`Unknown element type: ${childTag}`);
      continue;
    }

    // Create node for this child
    const { id: childId, node: childNode } = createNodeFromElement(
      child,
      parentId,
      context
    );

    // Add to CraftJSON
    craftJson[childId] = childNode;

    // Add child ID to parent's nodes array
    parentNode.nodes.push(childId);

    // Recurse for canvas elements and Form
    if (childNode.isCanvas || childNode.type.resolvedName === "Form") {
      processChildren(child, childId, craftJson, context);
    }
  }
}

/**
 * Convert XML-Craft string to CraftJSON
 *
 * @param xmlString - The XML-Craft string to convert
 * @param options - Optional conversion options
 * @returns The converted CraftJSON object
 *
 * @example
 * ```typescript
 * const xml = `
 *   <Page version="10" padding="0,0,0,0">
 *     <Container flexDirection="column">
 *       <Text textAlign="center">
 *         <p><span font="Inter" size="48px" weight="700">Hello</span></p>
 *       </Text>
 *     </Container>
 *   </Page>
 * `;
 * const craftJson = xmlToCraftJson(xml);
 * ```
 */
export function xmlToCraftJson(
  xmlString: string,
  options?: {
    /** Timestamp for deterministic ID generation (defaults to Date.now()) */
    timestamp?: number;
    /** Whether to validate the XML structure */
    validate?: boolean;
  }
): CraftJSON {
  // Parse XML
  const parser = new DOMParser();
  const doc = parser.parseFromString(xmlString, "application/xml");

  // Check for parse errors
  const parseError = doc.querySelector("parsererror");
  if (parseError) {
    throw new Error(`XML parse error: ${parseError.textContent}`);
  }

  const root = doc.documentElement;

  // Validate root is Page element
  if (root.tagName !== "Page") {
    throw new Error(`Root element must be <Page>, got <${root.tagName}>`);
  }

  // Create conversion context for deterministic IDs
  const context = createConversionContext(options?.timestamp);

  // Create ROOT node
  const { node: rootNode } = createNodeFromElement(root, null, context);

  // Initialize CraftJSON with ROOT
  const craftJson: Record<string, CraftNode | number> = {
    ROOT: rootNode,
  };

  // Process children recursively
  processChildren(root, "ROOT", craftJson, context);

  // Add version
  craftJson.version = 10;

  return craftJson as CraftJSON;
}

// =============================================================================
// CRAFTJSON TO XML CONVERSION
// =============================================================================

/**
 * Convert RGBA color to string "r,g,b,a"
 */
function rgbaToString(rgba: RGBA): string {
  return `${rgba.r},${rgba.g},${rgba.b},${rgba.a}`;
}

/**
 * Convert TRBL array to string "t,r,b,l"
 */
function trblToString(trbl: TRBL): string {
  return trbl.join(",");
}

/**
 * Convert visibility object to string "desktop,tablet,mobile"
 */
function visibilityToString(vis: VisibilitySettings): string {
  return `${vis.desktop},${vis.tablet},${vis.mobile}`;
}

/**
 * Convert a prop value to attribute string
 */
function valueToAttributeString(key: string, value: unknown): string | null {
  if (value === null || value === undefined) {
    return null;
  }

  // Array (TRBL)
  if (Array.isArray(value)) {
    return value.join(",");
  }

  // RGBA object
  if (isRGBAObject(value)) {
    return rgbaToString(value);
  }

  // Visibility object
  if (isVisibilityObject(value)) {
    return visibilityToString(value);
  }

  // Boolean
  if (typeof value === "boolean") {
    return value.toString();
  }

  // Number or string
  return String(value);
}

/**
 * Check if two values are deeply equal
 */
function deepEqual(a: unknown, b: unknown): boolean {
  if (a === b) return true;
  if (a === null || b === null) return false;
  if (typeof a !== typeof b) return false;

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((val, i) => deepEqual(val, b[i]));
  }

  if (typeof a === "object" && typeof b === "object") {
    const keysA = Object.keys(a as object);
    const keysB = Object.keys(b as object);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) =>
      deepEqual(
        (a as Record<string, unknown>)[key],
        (b as Record<string, unknown>)[key]
      )
    );
  }

  return false;
}

/**
 * Escape XML special characters
 */
function escapeXml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

/**
 * Build children map from CraftJSON
 */
function buildChildrenMap(craftJson: CraftJSON): Map<string, string[]> {
  const map = new Map<string, string[]>();

  for (const [id, node] of Object.entries(craftJson)) {
    if (id === "version" || typeof node === "number") continue;
    map.set(id, (node as CraftNode).nodes || []);
  }

  return map;
}

/**
 * Convert props to XML attributes, skipping defaults
 */
function propsToAttributes(
  props: Record<string, unknown>,
  resolvedName: string
): string {
  const defaults = COMPONENT_DEFAULTS[resolvedName] || {};
  const attrs: string[] = [];

  for (const [key, value] of Object.entries(props)) {
    // Skip breakpoint objects (handled separately)
    if (key === "tablet" || key === "mobile") continue;

    // Skip complex objects handled as child elements
    if (
      key === "clickEvent" ||
      key === "expireEvent" ||
      key === "followupAction" ||
      key === "textStyles" ||
      key === "options" ||
      key === "embedCode"
    ) {
      continue;
    }

    // Skip gradient backgrounds (handled as child element)
    if (key === "backgroundColor" && isGradient(value)) continue;

    // Skip if value equals default
    if (deepEqual(value, defaults[key])) continue;

    // Skip internal props
    if (key === "positionAnchorsState" || key === "breakpoint") continue;

    // Convert to attribute
    const attrValue = valueToAttributeString(key, value);
    if (attrValue !== null) {
      attrs.push(`${key}="${escapeXml(attrValue)}"`);
    }
  }

  return attrs.join(" ");
}

/**
 * Convert text styles to XML elements
 */
function textStylesToXml(textStyles: TextStyleParagraph[], indent: string): string {
  const lines: string[] = [];

  for (const paragraph of textStyles) {
    const spans: string[] = [];

    for (const span of paragraph.children) {
      const spanAttrs: string[] = [];

      if (span.fontFamily && span.fontFamily !== "Inter") {
        spanAttrs.push(`font="${escapeXml(span.fontFamily)}"`);
      }
      if (span.fontSize && span.fontSize !== "16px") {
        spanAttrs.push(`size="${escapeXml(span.fontSize)}"`);
      }
      if (span.fontWeight && span.fontWeight !== "400") {
        spanAttrs.push(`weight="${escapeXml(span.fontWeight)}"`);
      }
      if (span.fontStyle && span.fontStyle !== "normal") {
        spanAttrs.push(`style="${escapeXml(span.fontStyle)}"`);
      }
      if (span.textTransform && span.textTransform !== "none") {
        spanAttrs.push(`transform="${escapeXml(span.textTransform)}"`);
      }
      if (span.letterSpacing && span.letterSpacing !== 0) {
        spanAttrs.push(`spacing="${span.letterSpacing}"`);
      }
      if (span.color) {
        spanAttrs.push(`color="${rgbaToString(span.color)}"`);
      }

      const spanAttrStr = spanAttrs.length > 0 ? ` ${spanAttrs.join(" ")}` : "";
      spans.push(`<span${spanAttrStr}>${escapeXml(span.text)}</span>`);
    }

    lines.push(`${indent}  <p>${spans.join("")}</p>`);
  }

  return lines.join("\n");
}

/**
 * Convert click event to XML element
 */
function clickEventToXml(event: ClickEvent | ParsedClickEvent, indent: string): string {
  const attrs: string[] = [`type="${event.eventType}"`];

  if (event.eventData) {
    const data = event.eventData as Record<string, unknown>;
    if (data.url) attrs.push(`url="${escapeXml(String(data.url))}"`);
    if (data.pageId) attrs.push(`pageId="${escapeXml(String(data.pageId))}"`);
    if (data.optionId) attrs.push(`elementId="${escapeXml(String(data.optionId))}"`);
    if (data.newTab !== undefined) attrs.push(`newTab="${data.newTab}"`);
    if (data.useNofollow !== undefined) attrs.push(`nofollow="${data.useNofollow}"`);
  }

  return `${indent}<ClickEvent ${attrs.join(" ")} />`;
}

/**
 * Convert gradient to XML element
 */
function gradientToXml(gradient: GradientBackground, indent: string): string {
  const lines: string[] = [];
  const attrs = [`type="${gradient.type}"`];
  if (gradient.angle !== undefined) {
    attrs.push(`angle="${gradient.angle}"`);
  }

  lines.push(`${indent}<Gradient ${attrs.join(" ")}>`);
  for (const stop of gradient.stops) {
    lines.push(`${indent}  <Stop position="${stop.position}" color="${stop.color}" />`);
  }
  lines.push(`${indent}</Gradient>`);

  return lines.join("\n");
}

/**
 * Convert breakpoint overrides to XML element
 */
function breakpointToXml(
  breakpoint: "Tablet" | "Mobile",
  overrides: Record<string, unknown>,
  resolvedName: string,
  indent: string
): string | null {
  if (!overrides || Object.keys(overrides).length === 0) {
    return null;
  }

  const attrs: string[] = [];
  for (const [key, value] of Object.entries(overrides)) {
    const attrValue = valueToAttributeString(key, value);
    if (attrValue !== null) {
      attrs.push(`${key}="${escapeXml(attrValue)}"`);
    }
  }

  if (attrs.length === 0) {
    return null;
  }

  return `${indent}<${breakpoint} ${attrs.join(" ")} />`;
}

/**
 * Recursively convert a node and its children to XML
 */
function nodeToXml(
  nodeId: string,
  craftJson: CraftJSON,
  childrenMap: Map<string, string[]>,
  indent: string
): string {
  const node = craftJson[nodeId] as CraftNode;
  if (!node || typeof node === "number") {
    return "";
  }

  const resolvedName = node.type.resolvedName;
  const elementName = RESOLVED_NAME_TO_ELEMENT[resolvedName] || resolvedName;

  // Build attributes
  const attrs: string[] = [];

  // Add id if not auto-generated
  if (nodeId !== "ROOT" && !isAutoGeneratedId(nodeId)) {
    attrs.push(`id="${escapeXml(nodeId)}"`);
  }

  // Add displayName if customized
  if (node.custom?.displayName && node.custom.displayName !== resolvedName) {
    attrs.push(`displayName="${escapeXml(node.custom.displayName)}"`);
  }

  // Add isLocked if true
  if (node.custom?.isLocked) {
    attrs.push(`isLocked="true"`);
  }

  // Add hidden if true
  if (node.hidden) {
    attrs.push(`hidden="true"`);
  }

  // Add props as attributes
  const nodeProps = node.props as unknown as Record<string, unknown>;
  const propAttrs = propsToAttributes(nodeProps, resolvedName);
  if (propAttrs) {
    attrs.push(propAttrs);
  }

  const attrStr = attrs.length > 0 ? ` ${attrs.join(" ")}` : "";

  // Build child content
  const childContent: string[] = [];
  const childIndent = indent + "  ";

  // Add breakpoint overrides
  const props = nodeProps;
  const tabletXml = breakpointToXml(
    "Tablet",
    props.tablet as Record<string, unknown>,
    resolvedName,
    childIndent
  );
  if (tabletXml) childContent.push(tabletXml);

  const mobileXml = breakpointToXml(
    "Mobile",
    props.mobile as Record<string, unknown>,
    resolvedName,
    childIndent
  );
  if (mobileXml) childContent.push(mobileXml);

  // Add click event
  if (props.clickEvent && (props.clickEvent as ParsedClickEvent).eventType !== "nolink") {
    childContent.push(clickEventToXml(props.clickEvent as ParsedClickEvent, childIndent));
  }

  // Add expire event (Countdown)
  if (props.expireEvent) {
    const event = props.expireEvent as { eventType: string; url?: string };
    const eventAttrs = [`type="${event.eventType}"`];
    if (event.url) eventAttrs.push(`url="${escapeXml(event.url)}"`);
    childContent.push(`${childIndent}<ExpireEvent ${eventAttrs.join(" ")} />`);
  }

  // Add followup action (Form)
  if (props.followupAction) {
    const action = props.followupAction as { type: string; url?: string; message?: string };
    const actionAttrs = [`type="${action.type}"`];
    if (action.url) actionAttrs.push(`url="${escapeXml(action.url)}"`);
    if (action.message) actionAttrs.push(`message="${escapeXml(action.message)}"`);
    childContent.push(`${childIndent}<FollowupAction ${actionAttrs.join(" ")} />`);
  }

  // Add gradient background
  if (isGradient(props.backgroundColor)) {
    childContent.push(gradientToXml(props.backgroundColor, childIndent));
  }

  // Add text styles
  if (props.textStyles && Array.isArray(props.textStyles)) {
    childContent.push(textStylesToXml(props.textStyles as TextStyleParagraph[], indent));
  }

  // Add embed code (Video)
  if (props.embedCode) {
    childContent.push(
      `${childIndent}<EmbedCode><![CDATA[${props.embedCode}]]></EmbedCode>`
    );
  }

  // Add options (DropdownField, SelectionField)
  if (props.options && Array.isArray(props.options)) {
    for (const opt of props.options as Array<{ value: string; label: string }>) {
      childContent.push(
        `${childIndent}<Option value="${escapeXml(opt.value)}" label="${escapeXml(opt.label)}" />`
      );
    }
  }

  // Add child nodes
  const childIds = childrenMap.get(nodeId) || [];
  for (const childId of childIds) {
    const childXml = nodeToXml(childId, craftJson, childrenMap, childIndent);
    if (childXml) {
      childContent.push(childXml);
    }
  }

  // Build final XML
  if (childContent.length === 0) {
    return `${indent}<${elementName}${attrStr} />`;
  }

  return `${indent}<${elementName}${attrStr}>\n${childContent.join("\n")}\n${indent}</${elementName}>`;
}

/**
 * Convert CraftJSON to XML-Craft string
 *
 * @param craftJson - The CraftJSON object to convert
 * @returns The XML-Craft string representation
 *
 * @example
 * ```typescript
 * const xml = craftJsonToXml(craftJson);
 * console.log(xml);
 * // <?xml version="1.0" encoding="UTF-8"?>
 * // <Page version="10" ...>
 * //   ...
 * // </Page>
 * ```
 */
export function craftJsonToXml(craftJson: CraftJSON): string {
  // Validate
  if (!craftJson.ROOT) {
    throw new Error("CraftJSON must have ROOT node");
  }

  if (craftJson.ROOT.type.resolvedName !== "Page") {
    throw new Error("ROOT node must be Page component");
  }

  // Build children map
  const childrenMap = buildChildrenMap(craftJson);

  // Convert ROOT node (Page) with version attribute
  const rootNode = craftJson.ROOT;
  const version = craftJson.version || 10;

  // Build Page element
  const attrs: string[] = [`version="${version}"`];

  // Add displayName if customized
  if (rootNode.custom?.displayName && rootNode.custom.displayName !== "Page") {
    attrs.push(`displayName="${escapeXml(rootNode.custom.displayName)}"`);
  }

  // Add props as attributes
  const rootProps = rootNode.props as unknown as Record<string, unknown>;
  const propAttrs = propsToAttributes(rootProps, "Page");
  if (propAttrs) {
    attrs.push(propAttrs);
  }

  const attrStr = attrs.join(" ");

  // Build child content
  const childContent: string[] = [];
  const childIndent = "  ";

  // Add breakpoint overrides
  const props = rootProps;
  const tabletXml = breakpointToXml(
    "Tablet",
    props.tablet as Record<string, unknown>,
    "Page",
    childIndent
  );
  if (tabletXml) childContent.push(tabletXml);

  const mobileXml = breakpointToXml(
    "Mobile",
    props.mobile as Record<string, unknown>,
    "Page",
    childIndent
  );
  if (mobileXml) childContent.push(mobileXml);

  // Add child nodes
  const childIds = childrenMap.get("ROOT") || [];
  for (const childId of childIds) {
    const childXml = nodeToXml(childId, craftJson, childrenMap, childIndent);
    if (childXml) {
      childContent.push(childXml);
    }
  }

  // Build final XML
  const xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>';
  const pageContent =
    childContent.length > 0
      ? `\n${childContent.join("\n")}\n`
      : "";

  return `${xmlDeclaration}\n<Page ${attrStr}>${pageContent}</Page>`;
}

// =============================================================================
// VALIDATION
// =============================================================================

/**
 * Validate XML-Craft structure
 */
export function validateXmlCraft(xmlString: string): ValidationError[] {
  const errors: ValidationError[] = [];

  try {
    // Parse XML
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlString, "application/xml");

    // Check for parse errors
    const parseError = doc.querySelector("parsererror");
    if (parseError) {
      errors.push({
        code: "PARSE_ERROR",
        message: `XML parse error: ${parseError.textContent}`,
      });
      return errors;
    }

    const root = doc.documentElement;

    // V1: Root must be Page
    if (root.tagName !== "Page") {
      errors.push({
        code: "V1",
        message: `Root element must be <Page>, got <${root.tagName}>`,
        element: root.tagName,
      });
    }

    // Recursive validation helper
    const validateElement = (element: Element, parentIsForm: boolean): void => {
      const tagName = element.tagName;

      // Skip special elements
      if (SPECIAL_ELEMENTS.has(tagName)) {
        return;
      }

      // Check if valid element
      if (!ELEMENT_TO_RESOLVED_NAME[tagName]) {
        errors.push({
          code: "UNKNOWN_ELEMENT",
          message: `Unknown element type: ${tagName}`,
          element: tagName,
        });
        return;
      }

      // V3: Form fields can only be children of Form
      if (FORM_FIELD_ELEMENTS.has(tagName) && !parentIsForm) {
        errors.push({
          code: "V3",
          message: `Form field <${tagName}> can only appear inside <Form>`,
          element: tagName,
        });
      }

      // V2: Only canvas elements can have component children
      const isCanvas = CANVAS_ELEMENTS.has(tagName) || tagName === "Form";
      const isForm = tagName === "Form";

      const children = Array.from(element.children);
      for (const child of children) {
        const childTag = child.tagName;

        // Skip special elements
        if (SPECIAL_ELEMENTS.has(childTag)) {
          continue;
        }

        // Check if child is a component
        if (ELEMENT_TO_RESOLVED_NAME[childTag]) {
          if (!isCanvas) {
            errors.push({
              code: "V2",
              message: `Element <${tagName}> cannot have component children`,
              element: tagName,
            });
          }
        }

        validateElement(child, isForm);
      }

      // Validate attributes
      for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        const { name, value } = attr;

        // Skip special attributes
        if (name === "id" || name === "displayName" || name.startsWith("xmlns")) {
          continue;
        }

        // V7: TRBL format
        if (TRBL_ATTRIBUTES.has(name)) {
          const parts = value.split(",");
          if (![1, 2, 4].includes(parts.length)) {
            errors.push({
              code: "V7",
              message: `Invalid TRBL format: expected 1, 2, or 4 numbers`,
              element: tagName,
              attribute: name,
              value,
            });
          }
        }

        // V8: RGBA format
        if (COLOR_ATTRIBUTES.has(name) && value && value !== "transparent") {
          const parts = value.split(",");
          if (parts.length < 3 || parts.length > 4) {
            errors.push({
              code: "V8",
              message: `Invalid RGBA format: expected 3-4 numbers`,
              element: tagName,
              attribute: name,
              value,
            });
          }
        }

        // V9: Visibility format
        if (name === "visibility") {
          const parts = value.split(",");
          if (parts.length !== 3) {
            errors.push({
              code: "V9",
              message: `Invalid visibility format: expected 3 booleans`,
              element: tagName,
              attribute: name,
              value,
            });
          }
        }
      }
    };

    validateElement(root, false);
  } catch (e) {
    errors.push({
      code: "UNKNOWN_ERROR",
      message: `Validation error: ${e}`,
    });
  }

  return errors;
}

/**
 * Validate CraftJSON structure
 */
export function validateCraftJson(craftJson: CraftJSON): ValidationError[] {
  const errors: ValidationError[] = [];

  // Check ROOT exists
  if (!craftJson.ROOT) {
    errors.push({
      code: "NO_ROOT",
      message: "CraftJSON must have ROOT node",
    });
    return errors;
  }

  // Check ROOT is Page
  if (craftJson.ROOT.type.resolvedName !== "Page") {
    errors.push({
      code: "ROOT_NOT_PAGE",
      message: `ROOT node must be Page, got ${craftJson.ROOT.type.resolvedName}`,
    });
  }

  // Check all node references
  const nodeIds = new Set(
    Object.keys(craftJson).filter((k) => k !== "version")
  );

  for (const [id, node] of Object.entries(craftJson)) {
    if (id === "version" || typeof node === "number") continue;

    const craftNode = node as CraftNode;

    // Check parent reference
    if (craftNode.parent && !nodeIds.has(craftNode.parent)) {
      errors.push({
        code: "INVALID_PARENT",
        message: `Node ${id} references non-existent parent: ${craftNode.parent}`,
        element: id,
      });
    }

    // Check child references
    for (const childId of craftNode.nodes) {
      if (!nodeIds.has(childId)) {
        errors.push({
          code: "INVALID_CHILD",
          message: `Node ${id} references non-existent child: ${childId}`,
          element: id,
        });
      }
    }
  }

  return errors;
}
